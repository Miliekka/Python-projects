# -*- coding: utf-8 -*-
"""Numpy.Линейная алгебра.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qrbnG8Y8t9HurzsAIUtX7PTzaqiMUw2D
"""



import numpy as np
A = np.array([[6, 1, 1],
              [4, -2, 5],
              [2, 8, 7]])
print (A)
# Rank of a matrix
print("Rank of A:", np.linalg.matrix_rank (A)) # Trace of matrix A
print("\nTrace of A:", np.trace(A))
# Determinant of a matrix
print("\nDeterminant of A:", np.linalg.det (A)) # Inverse of matrix A
print("\nInverse of A:\n", np.linalg.inv (A)) # Transposition of matrix A
print("\nTransposition of A:\n", A.T)
# Multiplication of matrix A @ A.T
print("\nMultiplication of matrix A @ A.T:", A @ A.T)
print("\nMatrix A^2 raised to power 2: \n", np.linalg.matrix_power (A,
2))
# Multiplication of matrix A @ A
print("\nMultiplication of matrix A @ A:\n", A @ A)

"""Получить матричные и векторные произведения для вещественных и комплексных значений"""

import numpy as np
product = np.dot(5,4)
print("Dot Product of scalar values :", product)

vector_a = 2+3
vector_b = 4+5

product = np.dot(vector_a,vector_b)
print("Dot Product of real vector :", product)

vector_a = 2+3j
vector_b = 4+5j
product = np.dot(vector_a,vector_b)
print("Dot Product of complex vector :", product)

"""Исследуем матрицу и найдем решение СЛАУ для случая m=n"""

import numpy as np
np.set_printoptions(precision = 2, threshold=5)
m = 5
n = m
A=np.random.rand(m, n)
b=np.random.rand(m,1)
x = np.linalg.solve (A,b)
A_inv = np.linalg.inv(A)
b_calc=np.matmul (A_inv,x)
A_inv = np.linalg.inv(A)
x_inv = np.matmul (A_inv,b)
det_A = np.linalg.det (A)
AA_inv = np.matmul (A, np.linalg.inv(A))
print('Исходная матрица пространства R^5 A:\n',A, '\n')
print('Детерминант A =',det_A, '\n')
print('Решение х системы в пространстве R^5 solve(A,b):\n', x, '\n')
print('Обратная матрица A^-1 = 1/A\n',A_inv, '\n')
print('Решение х системы matmul(A_inv,b):\n',x, '\n')
print('Правая часть ь из пространства R^1: \n',b.T, '\n')
print('Расчётная правая часть: b_calc:\n',b_calc.T, '\n')
print(' Ошибка вектора правой части b_calc-b\n',b_calc-b,'\n',
      'Суммарная ошибка sum(b_calc-b) = ',sum(abs(b_calc-b)), '\n')
print('Единичная матрица АА^-1')
print('Вещественная АА^-1', AA_inv.dtype, '\n', AA_inv, '\n')
int_AA_inv = (AA_inv).astype(np. longlong)
print('Преобразование к целому типу АА^-1',int_AA_inv.dtype, '\n сразу из float64 АА^-1 выполняется с ошибками','\n', int_AA_inv, '\n')
int_AA_inv = np.around(AA_inv)
print('Округление AA^-1', AA_inv.dtype,'\n', int_AA_inv,'\n')

int_AA_inv = int_AA_inv.astype(np.longlong)
print('Преобразование к целому типу АА^-1',int_AA_inv.dtype, '\n после округления - выполняется правильно', '\n', int_AA_inv, '\n')

"""Исследуем матрицу и найдем решение СЛАУ для случая m>n"""

import numpy as np

# Рассмотрим пример для переопределённой системы
m = 10
n = 5
A=np.random.rand(m, n)
b=np.random.rand (m, 1)
ATA = A.T @ A
ATb = A.T @ b
x = np.linalg. solve (ATA, ATb)
b_calc=np.matmul (A,x)
ATA_inv = np.linalg.inv(ATA)
det_A= np.linalg.det(ATA)

print (f'Исxодная матрица пространства R^{n} A:\n',A, '\n')
print (f'Paнг Mатрицы А:\n',np.linalg.matrix_rank (A), '\n')
print('Детерминант АТА=',det_A, '\n',
      'Детерминант АТA =', np.linalg.det (ATA), '\n')
print(f'Правая часть ь из пространства R^{1}: \n',b,'\n', 'ATb из R^1: \n',ATb, '\n')
print('Рeщение x = solve (ATA, b):\n',x,'\n')
print('Обратная матрица АТА^-1',ATA_inv, '\n')
print('Точная правая часть b:\n',b.T,'\n')
print('Pacчěтная правая часть b_calc:\n',b_calc.T, '\n')
print('Oшибка вектора правой части b_calс-b\n', (b_calc-b).T, '\n',
      'Cуммарная ошибка sum (b_calc-b) = ', sum (abs (b_calc-b)), '\n')
print('Единичная матрица АТА @ ATA^-1')
print('Вешественная АТA @ АТА-1\n', ATA_inv @ ATA, '\n')
print('Округление АТА @ АТА^-1\n', np.around (ATA @ ATA_inv), '\n')
import matplotlib.pyplot as plt
plt.plot(b,b)
plt.plot(b,b_calc,"r*")
plt.show()

"""Исследуем матрицу и найдем решение СЛАУ для случая m<n"""

m = 3
n = 5
A=np.random.rand(m, n)
b=np.random.rand(m,1)
AAT = A @ A.T
det_A= np.linalg.det (AAT)
rank_A = np.linalg.matrix_rank(A)
AAT_inv = np.linalg.inv(AAT)
x=(A.T @ AAT_inv) @ b
b_calc = A @ x
print (f'Исxодная матрича пространства R^{n} A:\n',A, '\n',
       'Транспонированная А^Т =\n', A.T, '\n')
print (f'Paнг матрицы А:\n', rank_A, '\n')
print (f'Maтpица А@А^Т пространства R^{m} A:\n',AAT, '\n')
print('_Детерминант A=',det_A, '\n',
'Детерминант А@A^T=', np.linalg.det(AAT), '\n')
print(f'Правая часть ь из пространства R^{1}: \n',b,'\n')
print('Рeшeниe x = (AT @ (AAT)^-1) @ b):\n',x,'\n')
print('06ратная матрица АТА^-1 ',AAT_inv, '\n')
print('Точная правая часть b:\n',b.T, '\n')
print('Pacчëтная правая часть b_calc:\n',b_calc.T, '\n')
print('Oшибка вектора правой части b_сalс-b\n', (b_calc-b).T, '\n',
      'Суммарная ошибка sum(b_calc-b) = ', sum (abs (b_calc-b)), '\n')
print('Единичная матрица АТ @ AAT^-1')
print('Beшeственная АТА @ ATA^-1\n', AAT_inv @ AAT, '\n')
print('Округление АТА @ АТА^-1\n', np.around (AAT_inv @ AAT), '\n')
import matplotlib.pyplot as plt
plt.plot(b,b)
plt.plot(b,b_calc,"r*")
plt.show()

"""Задание 1.Метод Гаусса"""

import numpy as np
def gauss_elimination(matrix):
    n = matrix.shape[0]  # Размерность матрицы (число строк)
    matrix_clone = matrix.copy()
    # Прямой ход (Зануление нижнего левого угла)
    for k in range(n):  # k - номер строки
        # Деление k-строки на диагональный элемент (!=0) исходной матрицы
        matrix_clone[k, :] = matrix_clone[k, :] / matrix_clone[k, k]
        for i in range(k + 1, n):  # i - номер следующей строки после k
            # Коэффициент K для каждой i-й строки как отношение
            # к диагональному элементу матрицы клона
            K = matrix_clone[i, k]
            # Зануление всех элементов i-й строки матрицы
            # ниже первого члена, используя k-строку
            matrix_clone[i, :] -= K * matrix_clone[k, :]
     # Обратный ход (Зануление верхнего правого угла)
    for k in range(n - 1, -1, -1):  # k - номер строки
        # Деление k-строки на первый член != 0
        matrix_clone[k, :] /= matrix_clone[k, k]
        for i in range(k - 1, -1, -1):  # i - номер строки выше k
            K = matrix_clone[i, k]
            matrix_clone[i, :] -= K * matrix_clone[k, :]
    # Отделяем от общей матрицы ответы
    answer = matrix_clone[:, -1]  # последние столбцы являются ответами
    return answer
if __name__ == "__main__":
    A = np.array([[2, 1, -1, 8],
                  [-3, -1, 2, -11],
                  [-2, 1, 2, -3]], dtype=float)
    result = gauss_elimination(A)
    print("Решения системы уравнений:", result)

"""Задание 2.Исследуем линейную зависимость для всех 3-х примеров размерности mxn"""

import numpy as np

# 1. Создание матрицы A с заданными числами размерности n x m
A = np.array([[0.37, 0.73, 0.73, 0.6, 0.16],
              [0.16, 0.87, 0.87, 0.6, 0.71],
              [0.02, 0.83, 0.83, 0.21, 0.18],
              [0.18, 0.52, 0.52, 0.43, 0.29],
              [0.61, 0.29, 0.29, 0.37, 0.46]])

print("Исходная матрица A:\n", A, '\n')

# 2. Заменить в матрице A 1 столбец на 2 столбец
A[:, 0] = A[:, 1]
print('A после замены 1 столбца на 2 столбец:\n', A, '\n')

# 3. Выполнить все примеры из задания N° 1 (вычисление детерминанта)
det_A = np.linalg.det(A)
print('det A (испорченная):', det_A, '\n')

# 4. Заменить в матрице A 1 строку на 2 строку
A[0, :] = A[1, :]
print('A после замены 1 строки на 2 строку:\n', A, '\n')

# 5. Выполнить все примеры из задания N° 1 (вычисление детерминанта)
det_A_after_row_swap = np.linalg.det(A)
print('det A после замены 1 строки на 2 строку:', det_A_after_row_swap, '\n')

# Для исследования линейной зависимости
if det_A_after_row_swap == 0:
    print("Матрица A является вырожденной (линейно зависимые строки/столбцы).")
else:
    print("Матрица A является невырожденной (линейно независимые строки/столбцы).")
