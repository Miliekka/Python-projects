# -*- coding: utf-8 -*-
"""ИТМ-23_Хабибуллина_Камилла_Лаб_4_основы_scipy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oy7Wl9b6wWgqKQIsJsAKOFzNXtYO36vx

Физические константы
"""
import scipy.constants as CONST
print(CONST.g)
print(CONST.G)
print(CONST.c)
print(CONST.m_e)
#scipy.constants.physical_constants
print(CONST.physical_constants['elementary charge'])
print(CONST.physical_constants['molar gas constant'])
print(CONST.physical_constants['electron volt'])
#Множители
print(CONST.giga)
print(CONST.mega)
print(CONST.milli)
print(CONST.nano)
#Углы
print(CONST.degree)
print(CONST.arcminute)
print(CONST.arcsecond)

#Пример ф-ции превода угла,заданного в градусах и минутах дуги в радианы
def deg_min_to_radian(adeg,amin):
  return adeg*CONST.degree+amin*CONST.arcminute
deg_min_to_radian(45,22)

import scipy.constants as CONST
print('\nВремя')
print(CONST.minute)
print(CONST.hour)
print(CONST.day)
print(CONST.week)
print(CONST.year)
print('\nДлина')
print(CONST.inch)
print(CONST.mile)
print(CONST.micron)
print(CONST.light_year)
print(CONST.parsec)
print('\nДавление')
print(CONST.atm)
print(CONST.bar)
print(CONST.mmHg)
print(CONST.psi)
print('\nСкорость')
print(CONST.kmh)
print(CONST.mph)
print(CONST.mach)
print(CONST.knot)
print('\nСила,энергия,мощность')
print(CONST.eV)
print(CONST.calorie)
print(CONST.erg)
print(CONST.ton_TNT)
print(CONST.horsepower)
print(CONST.kgf)

import numpy as np
import scipy. constants as CONST
import matplotlib.pyplot as plt
#Радиус
R= 0.0005
#Плотность
rho = 1000.0
# Macca
m= rho * (4.0/3.0) *np. pi *R**3
#Массив долей скорости света: 9 точек от 0 до 0,1
k= np. linspace (0, 0.1, 9)
#Энергия (массив)
Energy = 0.5*m * (k*CONST.c) **2
#Энергия в тоннах THT
E_ton_TNT = Energy/CONST.ton_TNT
#Энергия в килограммах THT
E_kg_TNT= 1000.0*E_ton_TNT
#Построение графика
plt.figure(figsize=(6,3.5),dpi=150)
plt.plot(k,E_kg_TNT,'r-')
plt.xlabel('Скорость частицы , v/c')
plt.ylabel('Энергия частицы, кг THT')
plt.legend(['m={:3.2f} мг'.format(m*1e6)])
plt.grid(linestyle=':')

"""Тип numpy.matrix"""

import numpy as np
A = np.matrix([[1,2],[3,4]])
B = np.matrix([[1,2],[3,4]])
print(A*B)
A = np.array([[1,2],[3,4]])
B = np.array([[1,2],[3,4]])
print(A*B)
'''
"""Произведение матрицы и столбца"""

import numpy as np
A = np.matrix([[1,2],[3,4]])
b = np.matrix([1,2])
print(A*b)
#Возникает ошибка т.к размерности должны быть совместимы
'''
"""Исправленный вариант произведения матрицы и столбца"""

import numpy as np
A = np.matrix([[1,2],[3,4]])
b = np.matrix([1,2])
#Транспонирование матрицы строки b
print(A*b.T)
#или
A = np.matrix([[1,2],[3,4]])
b = np.matrix([[1],[2]])
print(A*b)

"""Обратная матрица"""

import numpy as np
from scipy import linalg
A = np.matrix([[1,2],[3,4]])
Ai = linalg.inv(A)
print(Ai)
print(A*Ai)

"""Решение СЛУ: обратная матрица"""

import numpy as np
from scipy import linalg
A = np.matrix([[1,3,5],[2,5,1],[2,3,8]])
b = np.matrix([[10],[8],[3]])

x = linalg.inv(A).dot(b)
print(x)

"""Решение СЛУ: ф-ция solve"""

import numpy as np
from scipy import linalg
A = np.matrix([[1,3,5],[2,5,1],[2,3,8]])
b = np.matrix([[10],[8],[3]])

x = linalg.solve(A,b)
print(x)

"""Вычисление определителя матрицы"""

import numpy as np
from scipy import linalg
A = np.matrix([[1,3,5],[2,5,1],[2,3,8]])
detA = linalg.det(A)
print(detA)

"""Собственные числа и собственные векторы"""

A = np.array([[1,2],[3,4]])
lamb,v = linalg.eig(A)
print(lamb)
print(v[:,0])
print(v[:,1])

"""Функция одной переменной"""

import numpy as np
from scipy.interpolate import interp1d
x= np.linspace(0,10,num=11,endpoint=True)
print(x)
y = np.cos(-x**2/9.0)
print(y)

#Табличная функция

import matplotlib.pyplot as plt
plt.plot(x,y,'o')

import matplotlib.pyplot as plt
plt.plot(x,y,'-')

"""линейная интерполяция"""

from scipy.interpolate import interp1d
f = interp1d(x,y)
print(f(2.5))
xnew=np.linspace(0,10,num=41,endpoint=True)
plt.plot(x,y,'o',xnew,f(xnew),'-')
plt.legend(['таблица','линейная интерп.'],
           loc='best')

"""Кубическая сплайн-интерполяция"""

from scipy.interpolate import interp1d
f = interp1d(x,y,kind='cubic')
print(f(2.5))
xnew=np.linspace(0,10,num=41,endpoint=True)
plt.plot(x,y,'o',xnew,f(xnew),'-')
plt.legend(['таблица','кубич. интерп.'],
           loc='best')

"""Нахождение корней уравнения"""

import numpy as np
from scipy.optimize import root
def func(x):
  return x+5*np.cos(x)

sol = root(func,-1)
print(sol.x,sol.success)

"""Решение системы нелинейных ур-ий"""

def func2(x):
  f = [x[0]*np.cos(x[1])-4,
       x[0]*x[1]-x[1]-5]
  return f
sol = root(func2,[1,1])
print(sol.x,sol.success)

"""Поиск минимума ф-ции"""

import numpy as np
from scipy.optimize import minimize

def time_AB(x,  a,b,h,v,k):
  La = np.sqrt(x**2+a**2)
  Lb = np.sqrt((h-x)**2+b**2)
  res = La/v + k*Lb/v
  return res
import matplotlib.pyplot as plt
x = time_AB(x,10,10,10,4,2)
y = np.arange(0,10,0.01)
plt.plot(x,'r-')
plt.xlabel('x,м')
plt.ylabel('$t_{AB}$,c')

import numpy as np
from scipy.optimize import minimize

def time_AB(x,  a,b,h,v,k):
  La = np.sqrt(x**2+a**2)
  Lb = np.sqrt((h-x)**2+b**2)
  res = La/v + k*Lb/v
  return res
res = minimize(time_AB,2.5,
               args = (10.0,10.0,10.0,4.0,2.0))
print(res.x,res.fun,res.success)

"""Зависимость x от отношения скоростей k"""

import numpy as np
from scipy.optimize import minimize

def x_opt(ki):
  return minimize(time_AB,2.5,
                  args = (10.0,10.0,10.0,4.0,ki)).x[0]
k = np.linspace(1,10,20)
xopt = np.fromiter((x_opt(ki)for ki in k),
                   dtype=float,
                   count = len(k))
plt.figure(figsize=(3,2),dpi = 200)
plt.plot(k,xopt,'r-')
plt.xlabel('k')
plt.ylabel('$x_{опт}$,м')

"""Определенные интегралы"""

import scipy.integrate as integrate
def fun(x):
  return x*np.sin(x)

result = integrate.quad(fun,0.0,1.0)
print(result)

import scipy.integrate as integrate
result = integrate.quad(lambda x:x*np.sin(x),0.0,1.0)
print(result)

"""Параметры подинтегральной ф-ции"""

import scipy.integrate as integrate

def integrand(x,n):
  return(x**n)*np.sin(x)

result = integrate.quad(integrand,0.0,1.0,
                        args = (3,))
print(result)

"""Двойной интеграл"""

import scipy.integrate as integrate

def integrand(x,y):
  return x*y
result = integrate.dblquad(integrand,0.0,0.5,
                        lambda x: 0,
                        lambda x: 1-2*x)
print(result)

"""Интегрирование табличной ф-ции"""

from scipy.integrate import simps

x = np.array([1.,2.,3.0,4.,5.0,6.])
y = np.array([2.,3.,3.5,4.,4.5,5.])
l1 = simps(y,x)
print(l1)

plt.plot(x,y,'o',x,y,'r-')

"""Форма Коши"""

def right_side(q,t):
  m=1.0
  c=10.0
  k=0.5

  dqdt = [q[1],-(k*q[1]+c*q[0])/m]
  return dqdt
from scipy.integrate import odeint
t = np.arange(0,10.0,0.01)
y0=[1.0,0]
q= odeint(right_side,y0,t)

plt.plot(t,q[:,0],'-',t,q[:,1],'--')
plt.xlabel('t,с')
plt.ylabel('y,м;v,м/c')
plt.legend(['положение','скорость'],loc = 'best')

"""задание 1"""

import numpy as np
import matplotlib.pyplot as plt

# Константы
G = 6.674 * (10 ** -11)  # м^3 / (кг * с^2)
M = 5.972 * (10 ** 24)   # кг
R = 6371                  # км

# Функция для вычисления ускорения свободного падения
def yskor(h):
    La = (R + h) ** 2
    Lb = G * M / La
    return Lb

# Высоты от 0 до 1000 км с шагом 100 км
heights = np.arange(0, 1001, 100)  # высота в км
g_values = yskor(heights)           # ускорение свободного падения для каждой высоты

# Печать таблицы
print("Высота (км)\tУскорение свободного падения (м/с^2)")
for h, g in zip(heights, g_values):
    print(f"{h}\t\t{g:.4f}")

# Визуализация
plt.plot(heights, g_values, 'r-')
plt.xlabel('Высота (км)')
plt.ylabel('Ускорение свободного падения (м/с^2)')
plt.title('Зависимость ускорения свободного падения от высоты')
plt.grid()
plt.show()

"""задание 2

"""

import numpy as np
from scipy import linalg

A = np.matrix([[2,3,1],[3,1,2],[1,2,3]])
b = np.matrix([[2],[7],[3]])

x = linalg.inv(A).dot(b)
print(x)

"""задание 3"""

import numpy as np
from scipy.integrate import trapz
def integrand(x):
  return (1 / np.sqrt(2 * np.pi)) * np.exp(-x**2 / 2)

x = np.linspace(-3, 3, 1000)  # Значения x от -3 до 3, 1000 точек
y = integrand(x)               # Значения функции в этих точках
result = trapz(y, x)
print(result)

"""задание 4

"""

import numpy as np
from scipy.optimize import root
def func(x):
  return x**3+np.cos(x)

sol = root(func,-1)
print(sol.x,sol.success)

"""задание 5"""

import numpy as np
from scipy.optimize import minimize

def find_min(x):
  x1 = x[0]
  x2 = x[1]
  La = (x2-x1**2)**2
  Lb = (1-x1)**2
  res = 100*La+Lb
  return res
x0 = np.array([1, 1])
res = minimize(find_min, x0)
print(res.x[0],res.x[1],res.fun,res.success)
